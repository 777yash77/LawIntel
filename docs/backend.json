{
  "entities": {
    "Article": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Article",
      "type": "object",
      "description": "Represents a legal article displayed on the homepage.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Article entity."
        },
        "title": {
          "type": "string",
          "description": "Title of the article."
        },
        "content": {
          "type": "string",
          "description": "Content of the article."
        },
        "publicationDate": {
          "type": "string",
          "description": "Date the article was published.",
          "format": "date-time"
        },
        "source": {
          "type": "string",
          "description": "Source of the article (e.g., news agency, journal)."
        },
        "imageUrl": {
          "type": "string",
          "description": "URL of the image associated with the article.",
          "format": "uri"
        }
      },
      "required": [
        "id",
        "title",
        "content",
        "publicationDate",
        "source"
      ]
    },
    "ChatHistory": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ChatHistory",
      "type": "object",
      "description": "Represents a single chat history.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the ChatHistory entity."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N ChatHistory)"
        },
        "timestamp": {
          "type": "string",
          "description": "Timestamp of when the chat message was sent.",
          "format": "date-time"
        },
        "userMessage": {
          "type": "string",
          "description": "User's message in the chat."
        },
        "geminiResponse": {
          "type": "string",
          "description": "Gemini API's response to the user's message."
        }
      },
      "required": [
        "id",
        "userId",
        "timestamp",
        "userMessage",
        "geminiResponse"
      ]
    },
    "User": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User",
      "type": "object",
      "description": "Represents a user of the application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the User entity."
        },
        "username": {
          "type": "string",
          "description": "Username of the user."
        },
        "email": {
          "type": "string",
          "description": "Email address of the user.",
          "format": "email"
        }
      },
      "required": [
        "id",
        "username",
        "email"
      ]
    },
    "EmergencyNumber": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "EmergencyNumber",
      "type": "object",
      "description": "Represents an emergency contact number.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the EmergencyNumber entity."
        },
        "name": {
          "type": "string",
          "description": "Name of the emergency service (e.g., Police, Fire Department)."
        },
        "phoneNumber": {
          "type": "string",
          "description": "Phone number for the emergency service."
        }
      },
      "required": [
        "id",
        "name",
        "phoneNumber"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/articles/{articleId}",
        "definition": {
          "entityName": "Article",
          "schema": {
            "$ref": "#/backend/entities/Article"
          },
          "description": "Stores legal articles displayed on the homepage. Assumes read access for all users.",
          "params": [
            {
              "name": "articleId",
              "description": "Unique identifier for the article."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Stores user profiles.",
          "params": [
            {
              "name": "userId",
              "description": "Unique identifier for the user."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/chat_history/{chatHistoryId}",
        "definition": {
          "entityName": "ChatHistory",
          "schema": {
            "$ref": "#/backend/entities/ChatHistory"
          },
          "description": "Stores chat history for each user. Includes denormalized 'userId' for authorization independence.",
          "params": [
            {
              "name": "userId",
              "description": "Unique identifier for the user."
            },
            {
              "name": "chatHistoryId",
              "description": "Unique identifier for the chat history entry."
            }
          ]
        }
      },
      {
        "path": "/emergency_numbers/{emergencyNumberId}",
        "definition": {
          "entityName": "EmergencyNumber",
          "schema": {
            "$ref": "#/backend/entities/EmergencyNumber"
          },
          "description": "Stores emergency contact numbers.",
          "params": [
            {
              "name": "emergencyNumberId",
              "description": "Unique identifier for the emergency number."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore data structure is designed to ensure security, scalability, and maintainability, following the principles of Authorization Independence, Clarity of Intent, and DBAC. It leverages denormalization to avoid hierarchical authorization dependencies and supports secure list operations. The structure is segregated to maintain a homogeneous security posture within each collection.\n\n**Authorization Independence:**\n\n*   `ChatHistory` documents include the `userId`. This denormalization allows security rules to validate user ownership without needing to perform expensive `get()` operations to verify the relationship between a chat history and its owner.\n\n**Structural Segregation:**\n\n*   Articles are stored in a top-level collection `/articles` assuming they have similar access requirements (e.g., read access for all users). If different articles require different authorization (e.g. only admins can see drafts) then these should be segregated into different collections, for example, `/articles_public` and `/articles_drafts`.\n\n**Access Modeling:**\n\n*   User-owned data, such as `ChatHistory`, is structured using path-based ownership under `/users/{userId}/chat_history/{chatHistoryId}`. This pattern simplifies the security rules.\n\n**QAPs (Rules are not Filters):**\n\n*   The structure supports secure `list` operations by ensuring that each collection has a clear, consistent security posture. For example, listing chat histories under `/users/{userId}/chat_history` can be secured by checking `request.auth.uid == userId` in the rules, guaranteeing that users can only list their own chat histories.\n\n**Invariants:**\n\n*   Timestamps can be enforced at the rule level. Ownership is inherent in the path structure for user-owned data."
  }
}
/**
 * @fileoverview Firestore Security Rules for Prototyping.
 *
 * Core Philosophy:
 * This ruleset prioritizes strict authorization and assumes flexible data shapes.
 * It enforces user-ownership and restricts access to user-specific data.
 *
 * Data Structure:
 * - /articles/{articleId}: Publicly readable articles.
 * - /users/{userId}: User profiles, accessible only to the owner.
 * - /users/{userId}/chat_history/{chatHistoryId}: Chat history for each user, accessible only to the owner.
 * - /emergency_numbers/{emergencyNumberId}: Emergency contact numbers, publicly readable.
 *
 * Key Security Decisions:
 * - Articles and emergency numbers are publicly readable.
 * - Chat history and user profiles are strictly user-owned.
 * - Data validation is minimized to relational integrity checks.
 *
 * Denormalization for Authorization:
 * - ChatHistory documents include the userId. This denormalization allows security rules to validate user ownership without needing to perform expensive get() operations to verify the relationship between a chat history and its owner.
 *
 * Structural Segregation:
 * - Articles are stored in a top-level collection /articles assuming they have similar access requirements (e.g., read access for all users). If different articles require different authorization (e.g. only admins can see drafts) then these should be segregated into different collections, for example, /articles_public and /articles_drafts.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows read access to all articles. Write access is not granted.
     * @path /articles/{articleId}
     * @allow (get, list) Any user can read any article.
     * @deny (create, update, delete) No one can create, update, or delete articles through the client.
     * @principle Public read access.
     */
    match /articles/{articleId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Manages user profile access. Only the user can read or write their own profile.
     * @path /users/{userId}
     * @allow (create) The user can create their profile if the userId matches their auth UID.
     * @allow (get, update, delete) The user can read, update, or delete their profile if the userId matches their auth UID.
     * @deny Any other user cannot access this profile.
     * @principle Enforces document ownership.
     */
    match /users/{userId} {
      allow get, update, delete: if isOwner(userId);
      allow create: if isOwner(userId);
      allow list: if false;
    }

    /**
     * @description Manages chat history access. Only the user can read or write their own chat history.
     * @path /users/{userId}/chat_history/{chatHistoryId}
     * @allow (create) The user can create chat history entries if the userId matches their auth UID.
     * @allow (get, list, update, delete) The user can read, list, update, or delete their chat history entries if the userId matches their auth UID.
     * @deny Any other user cannot access this chat history.
     * @principle Enforces document ownership within a subcollection.
     */
    match /users/{userId}/chat_history/{chatHistoryId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows read access to all emergency numbers. Write access is not granted.
     * @path /emergency_numbers/{emergencyNumberId}
     * @allow (get, list) Any user can read any emergency number.
     * @deny (create, update, delete) No one can create, update, or delete emergency numbers through the client.
     * @principle Public read access.
     */
    match /emergency_numbers/{emergencyNumberId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
        return isSignedIn() && request.auth.uid == userId && resource != null;
    }
  }
}